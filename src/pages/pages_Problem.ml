open BSReact

module CodeBlock = struct
  let component = RR.statelessComponent "CodeBlock"

  let make children = {
    component with
    render= fun _self ->
      div ~class_name:"code-block" [
        pre [
          code children
        ]
      ]
  }

  let c children =
    RR.element @@ make children
end

let component = RR.statelessComponent "Problem"

let make _children = {
  component with
  render= fun _self ->
    div ~class_name:"problem" [
      h1 [s "Gears Out!"];
      p [s {j|オフラインリアルタイムどう書く E26 問題|j}];
      h2 [s {j|問題文|j}];
      Parts.Board.c ~board:{ Board.size= 4; Board.gears= [|0; 2; 0; 3; 0; 2; 1; 0; 2; 0; 3; 0; 0; 2; 2; 1|] } [];
      p [s {j|図のように歯車が設置されています。歯車には印が付いていて、その場所に応じて「上」「右」「下」「左」の向きがあります。|j}];
      p [
        s {j|「上」向きの歯車を、|j};
        b [s {j|正しい向き|j}];
        s {j|の歯車とします。|j}
      ];
      p [
        s {j|歯車は|j};
        b [s {j|時計回り|j}];
        s {j|に回転させる事ができます。|j}
      ];
      p [
        s {j|ある歯車を回転させると、その上下左右の歯車が|j};
        b [s {j|反時計回りに|j}];
        s {j|回転します。|j}
      ];
      p [s {j|全ての歯車を「正しい向き」にするには、どのような手順で歯車を回していけば良いでしょうか？|j}];
      h2 [s {j|入力|j}];
      p [s {j|入力には2つの形式があり、好きな方を選ぶ事ができます。どちらも、表される状況は同じです。|j}];
      p [s {j|一つは、複数行で受け取る形式です。最初の行に縦横の大きさ N が出力され、以下 N 行に歯車の状態が出力されます。|j}];
      p [s {j|歯車の状態は全て数字で表され、「上」が "1" 、「右」が "2" 、「下」が "3" 、「左」が "4" です。|j}];
      p [s {j|1行につき、1つの横列分の歯車の状態を、空白区切りで表されます。|j}];
      CodeBlock.c [s {j|4
1 3 1 4
1 3 2 1
3 1 4 1
1 3 3 2|j}];
      p [
        s {j|この形式を|j};
        b [s {j|競プロ風|j}];
        s {j|と呼びます。|j}
      ];
      p [
        s {j|もう一つは、全て1行の文字列で受け取る形式です。最初に縦横の大きさがあり、パイプ （ |j};
        code [s {j| | |j}];
        s {j|） を挟んでその後ろに歯車の状態が並びます。|j}
      ];
      p [s {j|連続する数字が横一列の歯車を表し、各横列をカンマで区切ります。|j}];
      p [s {j|歯車の状態は同じく「上」が "1" 、「右」が "2" 、「下」が "3" 、「左」が "4" ですが、空白はありません。|j}];
      p [s {j|そして、実際の入力は、C言語や Java の関数呼び出しの形で与えられます。|j}];
      CodeBlock.c [s {j|test("4|1314,1321,3141,1332");|j}];
      p [
        s {j|この形式を|j};
        b [s {j|どうかく風|j}];
        s {j|と呼びます。|j}
      ];
      h3 [s {j|一括入力|j}];
      p [s {j|各テストケース毎に入力を受け取る以外に、全てのテストケースについて入力を受け取る事もできます。|j}];
      p [s {j|提出ページの上部に、一括入力用のテキストエリアがあります。|j}];
      p [s {j|競プロ風の入力の場合、最初の行にテストケースの数を表す数字 T が置かれます。|j}];
      p [s {j|2行目以降は、全てのテストケースの入力を改行区切りでつなげたものが続きます。|j}];
      CodeBlock.c [s {j|3
2
4 1
2 2
3
3 1 2
2 4 2
1 3 4
4
1 3 1 4
1 3 2 1
3 1 4 1
1 3 3 2|j}];
      p [s {j|どうかく風の入力の場合、単に各テストケースの入力を改行区切りで繋げたものが与えられます。|j}];
      p [s {j|ただし、関数呼び出しの前にコメントアウトされたテストケース番号が付きます。|j}];
      CodeBlock.c [s {j|/*0*/ test("2|41,22");
/*1*/ test("3|312,242,134");
/*2*/ test("4|1314,1321,3141,1332");|j}];
      h2 [s {j|出力|j}];
      p [s {j|回答は、歯車を動かす手順を1行ずつ出力してください。|j}];
      p [s {j|動かす歯車はx軸とy軸の座標で指定してください（座標は 1 から始まります。 0 からではありません）。|j}];
      p [s {j|1度の操作で、必ず1つの歯車を時計回りに90度だけ回す必要があります。それ以外の操作を行う事はできません。|j}];
      p [s {j|もし同じ歯車を180度以上回転させたい場合、同じ操作を複数回行ってください。|j}];
      p [s {j|各行には余計な出力をしてはいけません。|j}];
      p [s {j|不正な行があった場合、その時点で採点は中断され、テストは失敗します。|j}];
      p [s {j|出力の形式にも、競プロ風とどうかく風の2通りの方法があります。|j}];
      p [s {j|競プロ風出力では、1行につき1度の操作を、x座標とy座標とを空白区切りで出力します。|j}];
      CodeBlock.c [s {j|1 1
1 1
1 2
3 2
3 1
3 1
2 2
2 1
2 2|j}];
      p [s {j|どうかく風出力では、1行に全ての操作を出力します。座標はカンマ区切り、各操作はパイプ区切りで、空白を入れてはいけません。|j}];
      CodeBlock.c [s {j|1,1|1,1|1,2|3,2|3,1|3,1|2,2|2,1|2,2|j}];
      h3 [s {j|一括出力|j}];
      p [s {j|入力と同じく、出力も全てのテストケースに対して一括で行う事ができます。|j}];
      p [s {j|一括出力では注意が必要です。個別の出力とは異なり、「どのテストケースの出力なのか」を示す番号が必要になります。|j}];
      p [s {j|競プロ風の一括出力では、各テストケース毎の出力の先頭にテストケースの番号を入れます。|j}];
      p [s {j|また、各テストケース毎の出力を空白行で区切ります。|j}];
      CodeBlock.c [s {j|0
1 1
3 2
1 2

1
1 2
2 1
3 3
1 1

2
4 5|j}];
      p [s {j|どうかく風の一括出力では、まずテストケース番号を出力し、空白1文字をあけてから操作列を出力します。|j}];
      CodeBlock.c [s {j|0 1,1|3,2|1,2
1 1,2|2,1|3,3|1,1
2 4,5|j}];
    ]
}

let c children =
  RR.element @@ make children